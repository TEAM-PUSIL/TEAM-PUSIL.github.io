---
layout: post
title: "[푸실] ERD 정규화검토"
subtitle: ERD 정규화검토 시 찾아본 내용
categories: 푸실
tags: [side-project, task]
---


정규화 검토 중

인덱스를 따로 잡는 것과

복합키로 잡는 것 중 어느 것이 더 좋으냐는 의문 제기 됨

1. 복합키

복합키를 사용하면 여러 컬럼을 사용해서 조회할 때 인덱싱을 탈 수 있다.

다만, 키를 생성한 순서대로 조건을 걸어서 조회해야한다. 만약 A, B, C 순서대로 복합키를 걸고 B 혹은 C만 사용하여 조회하거나 조건에서 컬럼 순서를 변경해서 조회할 때는 인덱스를 타지 않음 (데이터베이스가 이미 효율적이지 않다고 판단했기 때문)

B-Tree 특성상 (A, B, C) 순서로 인덱스를 생성해놓고, 순서대로 A와 같은 값일 경우에 B를 찾아가는 형식이므로, 만약 B만 사용하여 조회한다면 해당하는 B를 찾기 위해 전체 행을 풀스캔 하게 된다.

B,C 만으로 조회할 일이 많다면 (B, C) 인덱스를 따로 생성해주어야 함.

1. 단일키 + 여러 개의 인덱스

여러 개의 인덱스를 생성해 놓았을 경우

단일 컬럼에 대해 조회할 때 좋다.

하지만 여러 컬럼에 대해 조회할 때는 인덱스 머지, 인덱스 선택 등의 정책에 따라 인덱스를 타게 되는데 이 때는 복합키 인덱싱보다 효율이 떨어진다.

그래서 결론은

1. 여러 컬럼을 조합하여 조회할 일이 많으면 복합키
2. 단일 컬럼으로 조회할 일이 많으면 그냥 인덱스를 생성
3. 여러 칼럼으로 조회하더라도 항상 복합키 인덱스 사용 규칙(순서, 칼럼 갯수)를 지키지 못할 거라면 그냥 필요 상황에 따라 복합 인덱스를 생성

참고 챗지피티

#질문

```jsx
그러면 

주어진 상황: A, B, C, D, F의 컬럼이 있는 테이블
주어진 쿼리 : select * from table where A = 'a' and B = 'b' and C = 'c'

일 때

1. A, B, C 복합키
2. A가 기본키, B 인덱스, C인덱스 각각 따로 존재
3. A가 기본키, (B, C) 복합 인덱스가 존재

위 세가지 중 어떤 것이 가장 효율적인데?
```

#답변

주어진 쿼리에 대해 가장 효율적인 인덱싱 전략은 대부분의 경우 `A, B, C` 복합키 인덱스일 것입니다. 하지만, 테이블의 다른 컬럼과 쿼리, 데이터 분포 등도 고려해야 합니다. 여기에 대한 각 옵션에 대한 일반적인 분석은 다음과 같습니다:

### 1. A, B, C 복합키

이 경우, `A, B, C`를 모두 사용하는 쿼리는 이 복합키 인덱스를 매우 효율적으로 사용할 수 있습니다. 이 인덱스를 통해 데이터베이스는 특정 `A, B, C` 값에 대한 레코드를 직접 탐색할 수 있으므로, 다른 옵션에 비해 일반적으로 가장 빠르게 결과를 반환할 것입니다.

### 2. A가 기본키, B 인덱스, C 인덱스 각각 따로 존재

이 경우, 데이터베이스는 인덱스 머지 또는 인덱스 선택 등의 전략을 사용해야 하며, 이러한 전략들은 복합키 인덱스를 사용하는 것보다 일반적으로 덜 효율적입니다.

### 3. A가 기본키, (B, C) 복합 인덱스가 존재

이 경우도 `(B, C)` 복합 인덱스는 `A`에 대한 조건 없이 `B`와 `C`만으로 검색하는데 효율적입니다. `A`가 기본키이므로 `A`에 대한 검색은 효율적이지만, `(B, C)` 복합 인덱스와 `A` 기본키 인덱스를 동시에 효율적으로 사용하기는 어렵습니다.

### 결론:

일반적으로, 주어진 쿼리 조건에 따라 `A, B, C` 복합키 인덱스가 가장 효율적일 것입니다. 하지만, 여러 다른 쿼리들과 데이터의 특성, 쿼리의 빈도 등을 고려하여 인덱스를 설계해야 하며, 특정 쿼리에 최적화된 인덱스 설계가 다른 쿼리의 성능에 영향을 미칠 수 있습니다. 실제 환경에서는 여러 인덱싱 전략을 테스트하고 성능을 측정하여 최적의 방법을 찾아야 합니다.

제1정규화 : 컬럼별 원자성

제2정규화 : 복합키 일때만 보면됨, 복합키의 일부 키에만 종속되는 컬럼이 있을 경우 위배. 즉 복합키 전체에 종속되어야 함

제3정규화 : 이행적 함수적 종속을 제거해야함. 즉, 기본키가 아닌 컬럼에 종속되는 컬럼이 있으면 안됨.

인덱스에 대한 CUD 오버헤드

네, 인덱스의 종류와 수에 따라 CUD(Create, Update, Delete) 연산 시 성능 차이가 발생할 수 있습니다. 인덱스는 데이터를 검색하는 속도를 향상시키지만, 데이터의 변경이 발생할 때는 추가적인 작업을 필요로 합니다. 여러 인덱스가 있거나 복합키 인덱스가 있을 때, 각 인덱스에 대한 유지 작업이 필요하므로, CUD 연산의 오버헤드가 증가할 수 있습니다.

### 1. **복수의 단일 컬럼 인덱스**

- 각각의 인덱스는 별도로 관리되며, CUD 연산이 발생하면 각 인덱스를 갱신해야 합니다.
- 이로 인해 여러 인덱스가 있을수록 CUD 연산의 오버헤드가 증가합니다.

### 2. **복합키 인덱스**

- 복합키 인덱스는 하나의 인덱스이지만, 여러 컬럼을 포함하고 있어 해당 컬럼 중 하나라도 변경되면 인덱스를 갱신해야 합니다.
- 단일 컬럼 인덱스에 비해 갱신이 복잡할 수 있으며, 따라서 CUD 연산의 오버헤드가 증가할 수 있습니다.

### 3. **인덱스 수와 종류**

- 인덱스의 수와 복잡도가 증가하면, 데이터를 변경할 때 필요한 작업도 복잡해지고 시간이 더 걸립니다.
- 따라서 특정 테이블에 너무 많은 인덱스를 생성하면, 조회 성능은 향상되지만, 데이터 변경 성능은 저하될 수 있습니다.

### 최적의 성능을 위한 전략

- 인덱스는 검색 성능 향상과 데이터 변경 오버헤드 사이의 트레이드오프가 있습니다.
- 읽기 위주의 작업이 많은 경우, 인덱스를 추가하여 조회 성능을 향상시킬 수 있습니다.
- 반면, 쓰기 위주의 작업이 많은 경우, 필요한 인덱스만 유지하고, 불필요한 인덱스는 제거하여 CUD 성능을 최적화할 수 있습니다.
- 실제 사용 사례에 따라 적절한 인덱스 전략을 세우고, 성능 테스트를 통해 최적의 구성을 찾아야 합니다.

PostgreSQL을 비롯한 대부분의 데이터베이스에서, CUD 연산에 대한 오버헤드는 인덱스의 수와 구조에 따라 달라집니다.

1. **3개의 단일 컬럼 인덱스**가 있는 경우:
  - 각 인덱스는 독립적으로 유지되므로, 하나의 컬럼만 변경되는 경우에는 해당 인덱스만 갱신하면 됩니다.
  - 그러나, 3개의 컬럼이 모두 다른 행을 대상으로 변경되는 상황이라면, 각각의 변경마다 각 인덱스를 갱신해야 합니다.
2. **3개의 컬럼에 대한 복합키 인덱스**가 있는 경우:
  - 하나의 복합키 인덱스만 유지하면 되므로, 단일 인덱스 관리의 복잡도는 일반적으로 낮습니다.
  - 그러나, 복합키 인덱스 내의 어느 하나의 컬럼이라도 변경되면, 전체 복합키 인덱스를 갱신해야 하므로, 오버헤드가 발생할 수 있습니다.

### 결론

- 만약 각 컬럼이 독립적으로 자주 변경된다면, 단일 컬럼 인덱스가 관리하기에 더 간편할 수 있습니다.
- 반면, 여러 컬럼이 함께 변경될 가능성이 높거나, 쿼리의 성능이 중요한 요소라면, 복합키 인덱스가 더 유리할 수 있습니다.
- 또한, 쿼리의 성능과 CUD의 오버헤드 사이에서 균형을 찾아야 합니다. 일반적으로 읽기 작업이 쓰기 작업보다 훨씬 빈번하게 발생하므로, 쿼리 성능을 최적화하는 것이 중요할 수 있습니다.
- PostgreSQL에서도 이러한 원칙이 적용되며, 특정 사용 사례에 따라 테스트와 측정을 통해 최적의 인덱스 전략을 찾아야 합니다.
